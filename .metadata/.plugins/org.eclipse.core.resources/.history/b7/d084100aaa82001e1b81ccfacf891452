package com.laptrinhjavaweb.dao.impl;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;

import com.laptrinhjavaweb.dao.INewsDAO;
import com.laptrinhjavaweb.mapper.NewsMapper;
import com.laptrinhjavaweb.model.NewsModel;

public class NewsDAO extends AbstractDAO<NewsModel> implements INewsDAO {

	@Override
	public List<NewsModel> findByCategoryId(Long categoryId) {

		String sql = "SELECT * FROM news WHERE categoryId = ?";

		return query(sql, new NewsMapper(), categoryId);
	}

	@Override
	public Long save(NewsModel newsModel) {
		String sql = "INSERT INTO news (title, content, categoryid) VALUES(?, ?, ?)";
		return insert(sql, newsModel.getTitle(), newsModel.getContent(), newsModel.getCategoryId());
	}

	// Hàm này là khi chưa xây dựng các hàm chung như update, insert trong
	// genericDAO.
	public Long saveVersion1(NewsModel newsModel) {

		String sql = "INSERT INTO news (title, content, categoryid) VALUES(?, ?, ?)";
		Connection connection = getConnection();
		ResultSet resultSet = null;
		PreparedStatement preparedStatement = null;
		Long id = null;

		try {
			connection.setAutoCommit(false); // chỉ khi success mới commit

			preparedStatement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			// sử dụng key statement Statement.RETURN_GENERATED_KEYS. Điều này thông báo cho
			// JDBC rằng bạn quan tâm đến các giá trị được tạo tự động.

			// set các giá trị cho từng tham số ? theo trình tự
			preparedStatement.setString(1, newsModel.getTitle());
			preparedStatement.setString(2, newsModel.getContent());
			preparedStatement.setLong(3, newsModel.getCategoryId());

			preparedStatement.executeUpdate(); // khi thêm, sửa, xóa đều dùng được executeUpdate()

			// lấy đối tượng resultSet có key - id được tạo auto
			resultSet = preparedStatement.getGeneratedKeys();
			if (resultSet.next()) {
//				resultSet.next(): Phương thức này di chuyển con trỏ đến dòng đầu tiên của ResultSet 
//				và trả về true nếu có dòng, hoặc false nếu không có dòng nào. 
//				Nếu có dòng, nó đưa con trỏ đến dòng đó để có thể lấy giá trị từ các cột.

				id = resultSet.getLong(1);
			}

			connection.commit(); // cần có commit() để có cả sự thay đổi dưới database
			return id;
		} catch (SQLException e) {
			if (connection != null) { // nếu connection == null thì khi gọi .roolback() -> error
				// nên ta kiểm tra trước.
				try {
					connection.rollback(); // lỗi xảy ra trong khối try thì reset về trạng thái ban đầu
				} catch (SQLException e1) {
					e1.printStackTrace();
				}
			}
			return null;
		} finally { // khi sd xong thì đóng tài nguyên lại -> best practice
			try {
				if (connection != null) {
					connection.close();
				}
				if (preparedStatement != null) {
					preparedStatement.close();
				}
				if (resultSet != null) {
					resultSet.close();
				}
			} catch (SQLException e) {
				return null;
			}
		}
	}

	@Override
	public NewsModel findOne(Long id) {
		String sql = "SELECT * FROM news WHERE id = ?";
		List<NewsModel> news = query(sql, new NewsMapper(), id);

		return news.isEmpty() ? null : news.get(0);
	}

	@Override
	public void update(NewsModel updatedNews) {
		StringBuilder sql = new StringBuilder("UPDATE news SET title = ?, thumbnail = ?, ");
		sql.append("shortdescription = ?, content = ?, categoryId = ?, ");
		sql.append("createddate = ?, createdby = ? WHERE id = ?");
		// sử dụng hàm update trong abstractDAO
		update(sql.toString(), updatedNews.getTitle(), updatedNews.getThumbnail(), updatedNews.getShortDescription(),
				updatedNews.getContent(), updatedNews.getCategoryId(), updatedNews.getCreatedDate(),
				updatedNews.getCreatedBy(), updatedNews.getId());
		
	}

	@Override
	public void delete(long id) {
		String sql = "DELETE FROM news WHERE id = ?";
		update(sql, id);
		
	}
}























